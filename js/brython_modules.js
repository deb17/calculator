__BRYTHON__.VFS_timestamp = 1588043343510
__BRYTHON__.use_VFS = true
var scripts = {"$timestamp": 1588043343510, "browser": [".py", "", [], 1], "math": [".js", "var $module = (function($B){\n\nvar _b_ = $B.builtins,\n    $s = [],\n    i\nfor(var $b in _b_){$s.push('var ' + $b +' = _b_[\"'+$b+'\"]')}\neval($s.join(';'))\n\n//for(var $py_builtin in _b_){eval(\"var \"+$py_builtin+\"=_b_[$py_builtin]\")}\n\nvar float_check = function(x) {\n    if(x.__class__ === $B.long_int){return parseInt(x.value)}\n    return _b_.float.$factory(x)\n}\n\nfunction check_int(x){\n    if(! _b_.isinstance(x, int)){\n        throw _b_.TypeError.$factory(\"'\" + $B.class_name(x) +\n            \"' object cannot be interpreted as an integer\")\n    }\n}\n\nfunction check_int_or_round_float(x){\n    return (x instanceof Number && x == Math.floor(x)) ||\n            _b_.isinstance(x, int)\n}\n\nvar isWholeNumber = function(x){return (x * 10) % 10 == 0}\n\nvar isOdd = function(x) {return isWholeNumber(x) && 2 * Math.floor(x / 2) != x}\n\nvar isLargeNumber = function(x) {return x > Math.pow(2, 32)}\n\n// Big number Library from jsfromhell.com\n// This library helps with producing \"correct\" results from\n// mathematic operations\n\n//+ Jonas Raoni Soares Silva\n//@ http://jsfromhell.com/classes/bignumber [rev. #4]\n\n\nvar BigNumber = function(n, p, r){\n    var o = this, i\n    if(n instanceof BigNumber){\n        for(i in {precision: 0, roundType: 0, _s: 0, _f: 0}){o[i] = n[i]}\n        o._d = n._d.slice()\n        return\n    }\n    o.precision = isNaN(p = Math.abs(p)) ? BigNumber.defaultPrecision : p\n    o.roundType = isNaN(r = Math.abs(r)) ? BigNumber.defaultRoundType : r\n    o._s = (n += \"\").charAt(0) == \"-\"\n    o._f = ((n = n.replace(/[^\\d.]/g, \"\").split(\".\", 2))[0] =\n        n[0].replace(/^0+/, \"\") || \"0\").length\n    for(i = (n = o._d = (n.join(\"\") || \"0\").split(\"\")).length; i;\n        n[--i] = +n[i]){}\n    o.round()\n}\nwith({$: BigNumber, o: BigNumber.prototype}){\n    $.ROUND_HALF_EVEN = ($.ROUND_HALF_DOWN = ($.ROUND_HALF_UP =\n        ($.ROUND_FLOOR = ($.ROUND_CEIL = ($.ROUND_DOWN = ($.ROUND_UP = 0) + 1) +\n            1) + 1) + 1) + 1) + 1\n    $.defaultPrecision = 40\n    $.defaultRoundType = $.ROUND_HALF_UP\n    o.add = function(n){\n        if(this._s != (n = new BigNumber(n))._s){\n            return n._s ^= 1, this.subtract(n)\n        }\n        var o = new BigNumber(this),\n            a = o._d,\n            b = n._d,\n            la = o._f,\n            lb = n._f,\n            n = Math.max(la, lb),\n            i,\n            r\n        la != lb && ((lb = la - lb) > 0 ? o._zeroes(b, lb, 1) :\n            o._zeroes(a, -lb, 1))\n        i = (la = a.length) == (lb = b.length) ? a.length :\n            ((lb = la - lb) > 0 ? o._zeroes(b, lb) : o._zeroes(a, -lb)).length\n        for(r = 0; i; r = (a[--i] = a[i] + b[i] + r) / 10 >>> 0, a[i] %= 10){}\n        return r && ++n && a.unshift(r), o._f = n, o.round()\n    };\n    o.subtract = function(n){\n        if(this._s != (n = new BigNumber(n))._s)\n            return n._s ^= 1, this.add(n);\n        var o = new BigNumber(this),\n            c = o.abs().compare(n.abs()) + 1,\n            a = c ? o : n,\n            b = c ? n : o,\n            la = a._f,\n            lb = b._f,\n            d = la,\n            i,\n            j;\n        a = a._d, b = b._d, la != lb && ((lb = la - lb) > 0 ? o._zeroes(b, lb, 1) : o._zeroes(a, -lb, 1));\n        for(i = (la = a.length) == (lb = b.length) ? a.length : ((lb = la - lb) > 0 ? o._zeroes(b, lb) : o._zeroes(a, -lb)).length; i;){\n            if(a[--i] < b[i]){\n                for(j = i; j && !a[--j]; a[j] = 9);\n                --a[j], a[i] += 10;\n            }\n            b[i] = a[i] - b[i];\n        }\n        return c || (o._s ^= 1), o._f = d, o._d = b, o.round();\n    };\n    o.multiply = function(n){\n        var o = new BigNumber(this), r = o._d.length >= (n = new BigNumber(n))._d.length, a = (r ? o : n)._d,\n        b = (r ? n : o)._d, la = a.length, lb = b.length, x = new BigNumber, i, j, s;\n        for(i = lb; i; r && s.unshift(r), x.set(x.add(new BigNumber(s.join(\"\")))))\n            for(s = (new Array(lb - --i)).join(\"0\").split(\"\"), r = 0, j = la; j; r += a[--j] * b[i], s.unshift(r % 10), r = (r / 10) >>> 0);\n        return o._s = o._s != n._s, o._f = ((r = la + lb - o._f - n._f) >= (j = (o._d = x._d).length) ? this._zeroes(o._d, r - j + 1, 1).length : j) - r, o.round();\n    };\n    o.divide = function(n){\n        if((n = new BigNumber(n)) == \"0\")\n            throw new Error(\"Division by 0\");\n        else if(this == \"0\")\n            return new BigNumber;\n        var o = new BigNumber(this), a = o._d, b = n._d, la = a.length - o._f,\n        lb = b.length - n._f, r = new BigNumber, i = 0, j, s, l, f = 1, c = 0, e = 0;\n        r._s = o._s != n._s, r.precision = Math.max(o.precision, n.precision),\n        r._f = +r._d.pop(), la != lb && o._zeroes(la > lb ? b : a, Math.abs(la - lb));\n        n._f = b.length, b = n, b._s = false, b = b.round();\n        for(n = new BigNumber; a[0] == \"0\"; a.shift());\n        out:\n        do{\n            for(l = c = 0, n == \"0\" && (n._d = [], n._f = 0); i < a.length && n.compare(b) == -1; ++i){\n                (l = i + 1 == a.length, (!f && ++c > 1 || (e = l && n == \"0\" && a[i] == \"0\")))\n                && (r._f == r._d.length && ++r._f, r._d.push(0));\n                (a[i] == \"0\" && n == \"0\") || (n._d.push(a[i]), ++n._f);\n                if(e)\n                    break out;\n                if((l && n.compare(b) == -1 && (r._f == r._d.length && ++r._f, 1)) || (l = 0))\n                    while(r._d.push(0), n._d.push(0), ++n._f, n.compare(b) == -1);\n            }\n            if(f = 0, n.compare(b) == -1 && !(l = 0))\n                while(l ? r._d.push(0) : l = 1, n._d.push(0), ++n._f, n.compare(b) == -1);\n            for(s = new BigNumber, j = 0; n.compare(y = s.add(b)) + 1 && ++j; s.set(y));\n            n.set(n.subtract(s)), !l && r._f == r._d.length && ++r._f, r._d.push(j);\n        }\n        while((i < a.length || n != \"0\") && (r._d.length - r._f) <= r.precision);\n        return r.round();\n    };\n    o.mod = function(n){\n        return this.subtract(this.divide(n).intPart().multiply(n));\n    };\n    o.pow = function(n){\n        var o = new BigNumber(this), i;\n        if((n = (new BigNumber(n)).intPart()) == 0) return o.set(1);\n        for(i = Math.abs(n); --i; o.set(o.multiply(this)));\n        return n < 0 ? o.set((new BigNumber(1)).divide(o)) : o;\n    };\n    o.set = function(n){\n        return this.constructor(n), this;\n    };\n    o.compare = function(n){\n        var a = this, la = this._f, b = new BigNumber(n), lb = b._f, r = [-1, 1], i, l;\n        if(a._s != b._s)\n            return a._s ? -1 : 1;\n        if(la != lb)\n            return r[(la > lb) ^ a._s];\n        for(la = (a = a._d).length, lb = (b = b._d).length, i = -1, l = Math.min(la, lb); ++i < l;)\n            if(a[i] != b[i])\n                return r[(a[i] > b[i]) ^ a._s];\n        return la != lb ? r[(la > lb) ^ a._s] : 0;\n    };\n    o.negate = function(){\n        var n = new BigNumber(this); return n._s ^= 1, n;\n    };\n    o.abs = function(){\n        var n = new BigNumber(this); return n._s = 0, n;\n    };\n    o.intPart = function(){\n        return new BigNumber((this._s ? \"-\" : \"\") + (this._d.slice(0, this._f).join(\"\") || \"0\"));\n    };\n    o.valueOf = o.toString = function(){\n        var o = this;\n        return (o._s ? \"-\" : \"\") + (o._d.slice(0, o._f).join(\"\") || \"0\") + (o._f != o._d.length ? \".\" + o._d.slice(o._f).join(\"\") : \"\");\n    };\n    o._zeroes = function(n, l, t){\n        var s = [\"push\", \"unshift\"][t || 0];\n        for(++l; --l;  n[s](0));\n        return n;\n    };\n    o.round = function(){\n        if(\"_rounding\" in this) return this;\n        var $ = BigNumber, r = this.roundType, b = this._d, d, p, n, x;\n        for(this._rounding = true; this._f > 1 && !b[0]; --this._f, b.shift());\n        for(d = this._f, p = this.precision + d, n = b[p]; b.length > d && !b[b.length -1]; b.pop());\n        x = (this._s ? \"-\" : \"\") + (p - d ? \"0.\" + this._zeroes([], p - d - 1).join(\"\") : \"\") + 1;\n        if(b.length > p){\n            n && (r == $.DOWN ? false : r == $.UP ? true : r == $.CEIL ? !this._s\n            : r == $.FLOOR ? this._s : r == $.HALF_UP ? n >= 5 : r == $.HALF_DOWN ? n > 5\n            : r == $.HALF_EVEN ? n >= 5 && b[p - 1] & 1 : false) && this.add(x);\n            b.splice(p, b.length - p);\n        }\n        return delete this._rounding, this;\n    };\n}\n\nvar isNegZero = function(x) {return x === 0 && Math.atan2(x,x) < 0}\n\nvar _mod = {\n    __getattr__: function(attr){\n        $B.check_nb_args('__getattr__ ', 1, arguments)\n        $B.check_no_kw('__getattr__ ', attr)\n\n        var res = this[attr]\n        if(res === undefined){\n            throw _b_.AttributeError.$factory(\n                'module math has no attribute ' + attr)\n        }\n        return res\n    },\n    acos: function(x){\n        $B.check_nb_args('acos', 1, arguments)\n        $B.check_no_kw('acos', x)\n        return float.$factory(Math.acos(float_check(x)))\n    },\n    acosh: function(x){\n        $B.check_nb_args('acosh', 1, arguments)\n        $B.check_no_kw('acosh', x)\n\n        if(_b_.$isinf(x)){return float.$factory('inf')}\n        var y = float_check(x)\n        return float.$factory(Math.log(y + Math.sqrt(y * y - 1)))\n    },\n    asin: function(x){\n        $B.check_nb_args('asin', 1, arguments)\n        $B.check_no_kw('asin', x)\n        return float.$factory(Math.asin(float_check(x)))\n    },\n    asinh: function(x){\n        $B.check_nb_args('asinh', 1, arguments)\n        $B.check_no_kw('asinh', x)\n\n        if(_b_.$isninf(x)){return float.$factory('-inf')}\n        if(_b_.$isinf(x)){return float.$factory('inf')}\n        var y = float_check(x)\n        return float.$factory(Math.log(y + Math.sqrt(y * y + 1)))\n    },\n    atan: function(x){\n        $B.check_nb_args('atan', 1, arguments)\n        $B.check_no_kw('atan', x)\n\n        if(_b_.$isninf(x)){return float.$factory(-Math.PI / 2)}\n        if(_b_.$isinf(x)){return float.$factory(Math.PI / 2)}\n        return float.$factory(Math.atan(float_check(x)))\n    },\n    atan2: function(y, x){\n        $B.check_nb_args('atan2', 2, arguments)\n        $B.check_no_kw('atan2', y, x)\n\n        return float.$factory(Math.atan2(float_check(y), float_check(x)))\n    },\n    atanh: function(x){\n        $B.check_nb_args('atanh', 1, arguments)\n        $B.check_no_kw('atanh', x)\n\n       var y = float_check(x)\n       if(y == 0){return 0}\n       return float.$factory(0.5 * Math.log((1 / y + 1)/(1 / y - 1)));\n    },\n    ceil: function(x){\n        $B.check_nb_args('ceil', 1, arguments)\n        $B.check_no_kw('ceil', x)\n\n       try{return getattr(x, '__ceil__')()}catch(err){}\n\n       if(_b_.$isninf(x)){return float.$factory('-inf')}\n       if(_b_.$isinf(x)){return float.$factory('inf')}\n       if(isNaN(x)){return float.$factory('nan')}\n\n       var y = float_check(x)\n       if(! isNaN(parseFloat(y)) && isFinite(y)){\n           return int.$factory(Math.ceil(y))\n       }\n\n       throw _b_.ValueError.$factory(\n           'object is not a number and does not contain __ceil__')\n    },\n    comb: function(n, k){\n        $B.check_nb_args('comb', 2, arguments)\n        $B.check_no_kw('comb', n, k)\n\n        // raise TypeError if n or k is not an integer\n        check_int(n)\n        check_int(k)\n\n        if(k < 0){\n            throw _b_.ValueError.$factory(\"k must be a non-negative integer\")\n        }\n        if(n < 0){\n            throw _b_.ValueError.$factory(\"n must be a non-negative integer\")\n        }\n\n        if(k > n){\n            return 0\n        }\n        // Evaluates to n! / (k! * (n - k)!)\n        var fn = _mod.factorial(n),\n            fk = _mod.factorial(k),\n            fn_k = _mod.factorial(n - k)\n        return $B.floordiv(fn, $B.mul(fk, fn_k))\n    },\n    copysign: function(x, y){\n        $B.check_nb_args('copysign', 2, arguments)\n        $B.check_no_kw('copysign', x,y)\n\n        var x1 = Math.abs(float_check(x))\n        var y1 = float_check(y)\n        var sign = Math.sign(y1)\n        sign = (sign == 1 || Object.is(sign, +0)) ? 1 : - 1\n        return float.$factory(x1 * sign)\n    },\n    cos : function(x){\n        $B.check_nb_args('cos ', 1, arguments)\n        $B.check_no_kw('cos ', x)\n        return float.$factory(Math.cos(float_check(x)))\n    },\n    cosh: function(x){\n        $B.check_nb_args('cosh', 1, arguments)\n        $B.check_no_kw('cosh', x)\n\n        if(_b_.$isinf(x)) {return float.$factory('inf')}\n        var y = float_check(x)\n        if(Math.cosh !== undefined){return float.$factory(Math.cosh(y))}\n        return float.$factory((Math.pow(Math.E, y) +\n            Math.pow(Math.E, -y)) / 2)\n    },\n    degrees: function(x){\n        $B.check_nb_args('degrees', 1, arguments)\n        $B.check_no_kw('degrees', x)\n        return float.$factory(float_check(x) * 180 / Math.PI)\n    },\n    dist: function(p, q){\n        $B.check_nb_args('dist', 2, arguments)\n        $B.check_no_kw('dist', p, q)\n        var itp = _b_.iter(p),\n            itq = _b_.iter(q),\n            res = 0\n        while(true){\n            try{\n                var next_p = _b_.next(itp)\n            }catch(err){\n                if(err.__class__ === _b_.StopIteration){\n                    // check that the other iterator is also exhausted\n                    try{\n                        var next_q = _b_.next(itq)\n                        throw _b_.ValueError.$factory(\"both points must have \" +\n                            \"the same number of dimensions\")\n                    }catch(err){\n                        if(err.__class__ === _b_.StopIteration){\n                            if(typeof res == \"number\"){\n                                return Math.sqrt(res)\n                            }else{\n                                return Math.sqrt(parseInt(res.value))\n                            }\n                        }\n                        throw err\n                    }\n                }\n                throw err\n            }\n            try{\n                var next_q = _b_.next(itq),\n                    diff = $B.sub(next_p, next_q)\n                res = $B.add(res, $B.mul(diff, diff))\n            }catch(err){\n                if(err.__class__ === _b_.StopIteration){\n                    throw _b_.ValueError.$factory(\"both points must have \" +\n                        \"the same number of dimensions\")\n                }\n                throw err\n            }\n        }\n    },\n    e: float.$factory(Math.E),\n    erf: function(x){\n        $B.check_nb_args('erf', 1, arguments)\n        $B.check_no_kw('erf', x)\n\n        // inspired from\n        // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n        var y = float_check(x)\n        var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n        var ans = 1 - t * Math.exp( -y * y - 1.26551223 +\n                     t * ( 1.00002368 +\n                     t * ( 0.37409196 +\n                     t * ( 0.09678418 +\n                     t * (-0.18628806 +\n                     t * ( 0.27886807 +\n                     t * (-1.13520398 +\n                     t * ( 1.48851587 +\n                     t * (-0.82215223 +\n                     t * 0.17087277)))))))))\n        if(y >= 0.0){return ans}\n        return -ans\n    },\n    erfc: function(x){\n\n        $B.check_nb_args('erfc', 1, arguments)\n        $B.check_no_kw('erfc', x)\n\n        // inspired from\n        // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n        var y = float_check(x)\n        var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n        var ans = 1 - t * Math.exp( -y * y - 1.26551223 +\n                     t * ( 1.00002368 +\n                     t * ( 0.37409196 +\n                     t * ( 0.09678418 +\n                     t * (-0.18628806 +\n                     t * ( 0.27886807 +\n                     t * (-1.13520398 +\n                     t * ( 1.48851587 +\n                     t * (-0.82215223 +\n                     t * 0.17087277)))))))))\n        if(y >= 0.0){return 1 - ans}\n        return 1 + ans\n    },\n    exp: function(x){\n        $B.check_nb_args('exp', 1, arguments)\n        $B.check_no_kw('exp', x)\n\n         if(_b_.$isninf(x)){return float.$factory(0)}\n         if(_b_.$isinf(x)){return float.$factory('inf')}\n         var _r = Math.exp(float_check(x))\n         if(_b_.$isinf(_r)){throw OverflowError(\"math range error\")}\n         return float.$factory(_r)\n    },\n    expm1: function(x){\n        $B.check_nb_args('expm1', 1, arguments)\n        $B.check_no_kw('expm1', x)\n\n         if(_b_.$isninf(x)){return float.$factory(0)}\n         if(_b_.$isinf(x)){return float.$factory('inf')}\n         var _r = Math.expm1(float_check(x))\n         if(_b_.$isinf(_r)){throw OverflowError(\"math range error\")}\n         return float.$factory(_r)\n    },\n    //fabs: function(x){ return x>0?float.$factory(x):float.$factory(-x)},\n    fabs: function(x){\n        $B.check_nb_args('fabs', 1, arguments)\n        $B.check_no_kw('fabs', x)\n        return _b_.$fabs(x) // located in py_float.js\n    },\n    factorial: function(x){\n        $B.check_nb_args('factorial', 1, arguments)\n        $B.check_no_kw('factorial', x)\n\n         //using code from http://stackoverflow.com/questions/3959211/fast-factorial-function-in-javascript\n         if(! check_int_or_round_float(x)){\n             throw _b_.ValueError.$factory(\"factorial() only accepts integral values\")\n         }else if($B.rich_comp(\"__lt__\", x, 0)){\n             throw _b_.ValueError.$factory(\"factorial() not defined for negative values\")\n         }\n         var r = 1\n         for(var i = 2; i <= x; i++){\n             r = $B.mul(r, i)\n         }\n         return r\n    },\n    floor: function(x){\n        $B.check_nb_args('floor', 1, arguments)\n        $B.check_no_kw('floor', x)\n        return Math.floor(float_check(x))\n    },\n    fmod: function(x,y){\n        $B.check_nb_args('fmod', 2, arguments)\n        $B.check_no_kw('fmod', x,y)\n        return float.$factory(float_check(x) % float_check(y))\n    },\n    frexp: function(x){\n        $B.check_nb_args('frexp', 1, arguments)\n        $B.check_no_kw('frexp', x)\n\n        var _l = _b_.$frexp(x)\n        return _b_.tuple.$factory([float.$factory(_l[0]), _l[1]])\n    },\n    fsum: function(x){\n        $B.check_nb_args('fsum', 1, arguments)\n        $B.check_no_kw('fsum', x)\n\n        /* Translation into Javascript of the function msum in an Active\n           State Cookbook recipe : https://code.activestate.com/recipes/393090/\n           by Raymond Hettinger\n        */\n        var partials = [],\n            res = new Number(),\n            _it = _b_.iter(x)\n        while(true){\n            try{\n                var x = _b_.next(_it),\n                    i = 0\n                for(var j = 0, len = partials.length; j < len; j++){\n                    var y = partials[j]\n                    if(Math.abs(x) < Math.abs(y)){\n                        var z = x\n                        x = y\n                        y = z\n                    }\n                    var hi = x + y,\n                        lo = y - (hi - x)\n                    if(lo){\n                        partials[i] = lo\n                        i++\n                    }\n                    x = hi\n                }\n                partials = partials.slice(0, i).concat([x])\n            }catch(err){\n                if(_b_.isinstance(err, _b_.StopIteration)){break}\n                throw err\n            }\n        }\n        var res = new Number(0)\n        for(var i = 0; i < partials.length; i++){\n            res += new Number(partials[i])\n        }\n        return new Number(res)\n    },\n    gamma: function(x){\n        $B.check_nb_args('gamma', 1, arguments)\n        $B.check_no_kw('gamma', x)\n\n        if(_b_.isinstance(x, int)){\n            if(i < 1){\n                throw _b_.ValueError.$factory(\"math domain error\")\n            }\n            var res = 1\n            for(var i = 1; i < x; i++){res *= i}\n            return new Number(res)\n        }\n        // Adapted from https://en.wikipedia.org/wiki/Lanczos_approximation\n        var p = [676.5203681218851,\n            -1259.1392167224028,\n            771.32342877765313,\n            -176.61502916214059,\n            12.507343278686905,\n            -0.13857109526572012,\n            9.9843695780195716e-6,\n            1.5056327351493116e-7\n            ]\n\n        var EPSILON = 1e-07\n        function drop_imag(z){\n            if(Math.abs(z.imag) <= EPSILON){\n                z = z.real\n            }\n            return z\n        }\n        var z = x\n        if(z < 0.5){\n            var y = Math.PI / (Math.sin(Math.PI * z) * _mod.gamma(1-z)) // Reflection formula\n        }else{\n            z -= 1\n            var x = 0.99999999999980993,\n                i = 0\n            for(var i = 0, len = p.length; i < len; i++){\n                var pval = p[i]\n                x += pval / (z + i + 1)\n            }\n            var t = z + p.length - 0.5,\n                sq = Math.sqrt(2 * Math.PI),\n                y = sq * Math.pow(t, (z + 0.5)) * Math.exp(-t) * x\n        }\n        return drop_imag(y)\n    },\n    gcd: function(){\n        var $ = $B.args(\"gcd\", 2, {a: null, b: null}, ['a', 'b'],\n                arguments, {}, null, null),\n            a = $B.PyNumber_Index($.a),\n            b = $B.PyNumber_Index($.b)\n        if(a == 0 && b == 0){return 0}\n        // https://stackoverflow.com/questions/17445231/js-how-to-find-the-greatest-common-divisor\n        a = _b_.abs(a)\n        b = _b_.abs(b)\n        if($B.rich_comp(\"__gt__\", b, a)){\n            var temp = a\n            a = b\n            b = temp\n        }\n        while(true){\n            if(b == 0){\n                return a\n            }\n            a = $B.rich_op(\"mod\", a, b)\n            if(a == 0){\n                return b\n            }\n            b = $B.rich_op(\"mod\", b, a)\n        }\n    },\n    hypot: function(x, y){\n        var $ = $B.args(\"hypot\", 2, {x: null, y:null}, ['x', 'y'],\n                    arguments, {}, \"args\", null),\n            args = [x, y].concat($.args),\n            res = 0\n        for (var i = 0, len = args.length; i < len; i++){\n            if(_b_.$isinf(args[i])){\n                return float.$factory('inf')\n            }\n            float_check(args[i])\n            res += args[i] * args[i]\n        }\n        return float.$factory(Math.sqrt(res))\n    },\n    inf: float.$factory('inf'),\n    isclose: function(){\n        var $ns = $B.args(\"isclose\",\n                          4,\n                          {a: null, b: null, rel_tol: null, abs_tol: null},\n                          ['a', 'b', 'rel_tol', 'abs_tol'],\n                          arguments,\n                          {rel_tol: 1e-09, abs_tol: 0.0},\n                          null,\n                          null)\n        var a = $ns['a'],\n            b = $ns['b'],\n            rel_tol = $ns['rel_tol'],\n            abs_tol = $ns['abs_tol']\n        if(rel_tol < 0.0 || abs_tol < 0.0){\n            throw ValueError('tolerances must be non-negative')\n        }\n        if(a == b){return True}\n        if(_b_.$isinf(a) || _b_.$isinf(b)){return false}\n        var diff = _b_.$fabs(b - a)\n        var result = (\n            (diff <= _b_.$fabs(rel_tol * b)) ||\n                (diff <= _b_.$fabs(rel_tol * a))\n            ) || (diff <= _b_.$fabs(abs_tol)\n        )\n        return result\n    },\n    isfinite: function(x){\n        $B.check_nb_args('isfinite', 1, arguments)\n        $B.check_no_kw('isfinite', x)\n        return isFinite(float_check(x))\n    },\n    isinf: function(x){\n        $B.check_nb_args('isinf', 1, arguments)\n        $B.check_no_kw('isinf', x)\n        return _b_.$isinf(float_check(x))\n    },\n    isnan: function(x){\n        $B.check_nb_args('isnan', 1, arguments)\n        $B.check_no_kw('isnan', x)\n        return isNaN(float_check(x))\n    },\n    isqrt: function(x){\n        $B.check_nb_args('isqrt', 1, arguments)\n        $B.check_no_kw('isqrt', x)\n\n        x = $B.PyNumber_Index(x)\n        if($B.rich_comp(\"__lt__\", x, 0)){\n            throw _b_.ValueError.$factory(\n                \"isqrt() argument must be nonnegative\")\n        }\n        if(typeof x == \"number\"){\n            return Math.floor(Math.sqrt(x))\n        }else{ // big integer\n            var v = parseInt(x.value),\n                candidate = Math.floor(Math.sqrt(v)),\n                c1\n            // Use successive approximations : sqr = (sqr + (x / sqr)) / 2\n            // Limit to 100 iterations\n            for(var i = 0; i < 100; i++){\n                c1 = $B.floordiv($B.add(candidate,\n                    $B.floordiv(x, candidate)), 2)\n                if(c1 === candidate || c1.value === candidate.value){\n                    break\n                }\n                candidate = c1\n            }\n            if($B.rich_comp(\"__gt__\", $B.mul(candidate, candidate), x)){\n                // Result might be greater by 1\n                candidate = $B.sub(candidate, 1)\n            }\n            return candidate\n        }\n    },\n    ldexp: function(x, i){\n        $B.check_nb_args('ldexp', 2, arguments)\n        $B.check_no_kw('ldexp', x, i)\n        return _b_.$ldexp(x, i)   //located in py_float.js\n    },\n    lgamma: function(x){\n        $B.check_nb_args('lgamma', 1, arguments)\n        $B.check_no_kw('lgamma', x)\n\n        return new Number(Math.log(Math.abs(_mod.gamma(x))))\n    },\n    log: function(x, base){\n        var $ = $B.args(\"log\", 2, {x: null, base: null}, ['x', 'base'],\n            arguments, {base: _b_.None}, null, null),\n            x = $.x,\n            base = $.base\n\n         var x1 = float_check(x)\n         if(base === _b_.None){return float.$factory(Math.log(x1))}\n         return float.$factory(Math.log(x1) / Math.log(float_check(base)))\n    },\n    log1p: function(x){\n        $B.check_nb_args('log1p', 1, arguments)\n        $B.check_no_kw('log1p', x)\n        return float.$factory(Math.log1p(float_check(x)))\n    },\n    log2: function(x){\n        $B.check_nb_args('log2', 1, arguments)\n        $B.check_no_kw('log2', x)\n\n        if(isNaN(x)){return float.$factory('nan')}\n        if(_b_.$isninf(x)) {throw ValueError('')}\n        var x1 = float_check(x)\n        if(x1 < 0.0){throw ValueError('')}\n        return float.$factory(Math.log(x1) / Math.LN2)\n    },\n    log10: function(x){\n        $B.check_nb_args('log10', 1, arguments)\n        $B.check_no_kw('log10', x)\n\n        return float.$factory(Math.log10(float_check(x)))\n    },\n    modf: function(x){\n        $B.check_nb_args('modf', 1, arguments)\n        $B.check_no_kw('modf', x)\n\n       if(_b_.$isninf(x)){\n           return _b_.tuple.$factory([0.0, float.$factory('-inf')])\n       }\n       if(_b_.$isinf(x)){\n           return _b_.tuple.$factory([0.0, float.$factory('inf')])\n       }\n       if(isNaN(x)){\n           return _b_.tuple.$factory([float.$factory('nan'),\n               float.$factory('nan')])\n       }\n\n       var x1 = float_check(x)\n       if(x1 > 0){\n          var i = float.$factory(x1 - Math.floor(x1))\n          return _b_.tuple.$factory([i, float.$factory(x1 - i)])\n       }\n\n       var x2 = Math.ceil(x1)\n       var i = float.$factory(x1 - x2)\n       return _b_.tuple.$factory([i, float.$factory(x2)])\n    },\n    nan: float.$factory('nan'),\n    perm: function(n, k){\n        var $ = $B.args(\"perm\", 2, {n: null, k: null}, ['n', 'k'],\n                        arguments, {k: _b_.None}, null, null),\n            n = $.n,\n            k = $.k\n\n        if(k === _b_.None){\n            check_int(n)\n            return _mod.factorial(n)\n        }\n        // raise TypeError if n or k is not an integer\n        check_int(n)\n        check_int(k)\n\n        if(k < 0){\n            throw _b_.ValueError.$factory(\"k must be a non-negative integer\")\n        }\n        if(n < 0){\n            throw _b_.ValueError.$factory(\"n must be a non-negative integer\")\n        }\n\n        if(k > n){\n            return 0\n        }\n        // Evaluates to n! / (n - k)!\n        var fn = _mod.factorial(n),\n            fn_k = _mod.factorial(n - k)\n        return $B.floordiv(fn, fn_k)\n    },\n    pi : float.$factory(Math.PI),\n    pow: function(x, y){\n        $B.check_nb_args('pow', 2, arguments)\n        $B.check_no_kw('pow', x,y)\n\n        var x1 = float_check(x)\n        var y1 = float_check(y)\n        if(y1 == 0){return float.$factory(1)}\n        if(x1 == 0 && y1 < 0){throw _b_.ValueError('')}\n\n        if(isNaN(y1)){\n            if(x1 == 1){return float.$factory(1)}\n            return float.$factory('nan')\n        }\n        if(x1 == 0){return float.$factory(0)}\n\n        if(_b_.$isninf(y)){\n            if(x1 == 1 || x1 == -1){return float.$factory(1)}\n            if(x1 < 1 && x1 > -1){return float.$factory('inf')}\n            return float.$factory(0)\n        }\n        if(_b_.$isinf(y)){\n            if(x1 == 1 || x1 == -1){return float.$factory(1)}\n            if(x1 < 1 && x1 > -1){return float.$factory(0)}\n            return float.$factory('inf')\n        }\n\n        if(isNaN(x1)){return float.$factory('nan')}\n        if(_b_.$isninf(x)){\n            if(y1 > 0 && isOdd(y1)){return float.$factory('-inf')}\n            if(y1 > 0){return float.$factory('inf')}  // this is even or a float\n            if(y1 < 0){return float.$factory(0)}\n            return float.$factory(1)\n        }\n\n        if(_b_.$isinf(x)){\n            if(y1 > 0){return float.$factory('inf')}\n            if(y1 < 0){return float.$factory(0)}\n            return float.$factory(1)\n        }\n\n        var r\n        if(isLargeNumber(x1) || isLargeNumber(y1)){\n           var x = new BigNumber(x1),\n               y = new BigNumber(y1)\n           r = x.pow(y)\n        }else{\n           r = Math.pow(x1,y1)\n        }\n\n        if(isNaN(r)){return float.$factory('nan')}\n        if(_b_.$isninf(r)){return float.$factory('-inf')}\n        if(_b_.$isinf(r)){return float.$factory('inf')}\n\n        return r\n    },\n    prod: function(){\n        var $ = $B.args(\"prod\", 1, {iterable:null, start:null},\n                        [\"iterable\", \"start\"], arguments, {start: 1}, \"*\",\n                        null),\n            iterable = $.iterable,\n            start = $.start\n        var res = start,\n            it = _b_.iter(iterable),\n            x\n        while(true){\n            try{\n                x = _b_.next(it)\n                if(x == 0){\n                    return 0\n                }\n                res = $B.mul(res, x)\n            }catch(err){\n                if(err.__class__ === _b_.StopIteration){\n                    return res\n                }\n                throw err\n            }\n        }\n    },\n    radians: function(x){\n        $B.check_nb_args('radians', 1, arguments)\n        $B.check_no_kw('radians', x)\n\n        return float.$factory(float_check(x) * Math.PI / 180)\n    },\n    sin : function(x){\n        $B.check_nb_args('sin ', 1, arguments)\n        $B.check_no_kw('sin ', x)\n        return float.$factory(Math.sin(float_check(x)))},\n    sinh: function(x) {\n        $B.check_nb_args('sinh', 1, arguments)\n        $B.check_no_kw('sinh', x)\n\n        var y = float_check(x)\n        if(Math.sinh !== undefined){return float.$factory(Math.sinh(y))}\n        return float.$factory(\n            (Math.pow(Math.E, y) - Math.pow(Math.E, -y)) / 2)\n    },\n    sqrt: function(x){\n        $B.check_nb_args('sqrt ', 1, arguments)\n        $B.check_no_kw('sqrt ', x)\n\n      var y = float_check(x)\n      if(y < 0){throw ValueError(\"math range error\")}\n      if(_b_.$isinf(y)){return float.$factory('inf')}\n      var _r = Math.sqrt(y)\n      if(_b_.$isinf(_r)){throw OverflowError(\"math range error\")}\n      return float.$factory(_r)\n    },\n    tan: function(x) {\n        $B.check_nb_args('tan', 1, arguments)\n        $B.check_no_kw('tan', x)\n\n        var y = float_check(x)\n        return float.$factory(Math.tan(y))\n    },\n    tanh: function(x) {\n        $B.check_nb_args('tanh', 1, arguments)\n        $B.check_no_kw('tanh', x)\n\n        var y = float_check(x)\n        if(Math.tanh !== undefined){return float.$factory(Math.tanh(y))}\n        return float.$factory((Math.pow(Math.E, y) - Math.pow(Math.E, -y))/\n             (Math.pow(Math.E, y) + Math.pow(Math.E, -y)))\n    },\n    trunc: function(x) {\n        $B.check_nb_args('trunc', 1, arguments)\n        $B.check_no_kw('trunc', x)\n\n       try{return getattr(x, '__trunc__')()}catch(err){}\n       var x1 = float_check(x)\n       if(!isNaN(parseFloat(x1)) && isFinite(x1)){\n          if(Math.trunc !== undefined){return int.$factory(Math.trunc(x1))}\n          if(x1 > 0){return int.$factory(Math.floor(x1))}\n          return int.$factory(Math.ceil(x1))  // x1 < 0\n       }\n       throw _b_.ValueError.$factory(\n           'object is not a number and does not contain __trunc__')\n    }\n}\n\nfor(var $attr in _mod){\n    if(typeof _mod[$attr] === 'function'){\n        _mod[$attr].__repr__ = (function(func){\n            return function(){return '<built-in function ' + func + '>'}\n        })($attr)\n        _mod[$attr].__str__ = (function(func){\n            return function(){return '<built-in function ' + func + '>'}\n        })($attr)\n    }\n}\n\nreturn _mod\n\n})(__BRYTHON__)\n"]}
__BRYTHON__.update_VFS(scripts)